이번에는 JPA의 내부 동작에 대한 이론에 대해서 공부해보도록 하자. JPA를 이해하려면 영속성 컨텍스트에 대한 이해가 반드시 필요하다.

JPA에서 가장 중요한 2가지를 꼽으라면 아래 둘을 꼽는다.

1. 객체와 관계형 데이터베이스 매핑하기(Object Relational Mapping, ORM)
2. **영속성 컨텍스트**

이번에는 영속성 컨텍스트에 대해 얘기해보자.

## 엔티티 매니저 팩토리 & 엔티티 매니저

영속성 컨텍스트를 이해하려면 먼저 엔티티 매니저 팩토리와 엔티티 매니저에 대해 이해해야 한다.

- **엔티티 매니저 팩토리(Entity Manager Factory)**: 웹 어플리케이션에 하나만 존재하며, 고객의 요청이 들어올 때마다 엔티티 매니저를 생성하는 역할을 한다.
- 엔티티 매니저(**Entity Manager**): 내부적으로 데이터베이스 커넥션을 사용해 DB와 소통한다.

![img.png](img.png)

엥, 정작 영속성 컨텍스트에 대한 설명은 나오지 않았는데? 바로 가보자.

## 영속성 컨텍스트

영속성 컨텍스트(Persistence Context)란 `엔티티를 영구 저장하는 환경`이라는 의미를 갖는다. 코드로는 아래와 같이 엔티티 매니저의 메소드 `persist()`를 호출함으로써 엔티티를 영속성 컨텍스트에 영속화할 수 있다.

```java
EntityManager.persist(entity);
```

그런데 뭔가 이상하다. 영속화한다는 것의 의미가 정확히 무엇인지 나오지 않았다. 보통 `영속화한다`고 하면 메모리는 임시적으로 저장하는 곳이고 디스크가 영속적으로 저장하는 곳이니 `디스크에 저장하는 것을 영속화한다는 건가?` 라고 생각할 수 있다. 그런데 그렇지 않다. DB에 저장한다는 게 아니라 영속성 컨텍스트라고 하는 애플리케이션 내 논리적 공간에 영속화시키는 것을 뜻한다.

따라서 위의 persist() 메소드를 호출하면 해당 엔티티는 영속성 컨텍스트에 등록되는 것이지, DB에 저장되지 않는다. 실제로 DB에 저장되는 시점은 트랜잭션이 커밋되는 시점에서다. 여기서 `영속` 이라는 단어에 헷갈리면 안된다. 영속성 컨텍스트는 일종의 서버 내에서 `DB에 대한 캐시` 역할을 하는 놈이며 영속화될 수 있는 엔티티를 관리하는 논리 공간이지 여기에 등록됐다고 데이터가 영속화(=DB에 저장)되는 게 아니라는 것. 만약 트랜잭션 커밋 시점에 문제가 생겨 롤백하게 되면 엔티티가 영속성 컨텍스트에 등록되었다고 하더라도 DB에 저장되지 않을 것이다.

## 엔티티의 생명주기

그러면 엔티티는 영속성 컨텍스트에 등록되기 전후로 어떤 생명주기를 거치는 것일까? 아래 이미지로 요약할 수 있다.

![img_1.png](img_1.png)

- 비영속 상태(New)
    - 객체를 새로 생성했을 때, 이 객체를 따로 등록하지 않는 이상 해당 객체는 비영속 상태에 해당한다.

    ```java
    Member member = new Member();
    member.setId("member1);
    member.setUsername("회원1");
    ```

  ![img_2.png](img_2.png)

- 영속 상태(Managed)
    - 비영속 상태의 객체를 엔티티 매니저에 등록했을 때의 상태에 해당한다.
    - 구현 방식은 엔티티 매니저의 메소드 `persist()`에 해당 엔티티를 인자로 넣어 호출한다.

    ```java
    Member member = new Member();
    member.setId("member1);
    member.setUsername("회원1");
    
    EntityManager em = emf.createEntityManager();
    em.getTransaction().begin(); // 트랜잭션 시작
    
    // 객체를 저장한 상태(영속)
    em.persist(member);
    ```
  - 이때 주의점: 위에서도 얘기했듯, 엔티티를 영속 상태에 등록한다고 DB에 저장되는 게 아니다. 아래 코드를 보자.

  ```java
  ...
  Member member = new Member();
  member.setId("member1);
  member.setUsername("회원1");
  
  EntityManager em = emf.createEntityManager();
  em.getTransaction().begin(); // 트랜잭션 시작
  
  // 객체를 저장한 상태(영속)
  System.out.println("===Before===");
  em.persist(member);
  System.out.println("===After===");
  tx.commit();
  ```

  위의 코드를 실행하면 아래와 같이 출력된다.
  
  ```java
  ===Before===
  ===After===
  Insert ...(Insert 쿼리)
  ```
  보다시피 insert 쿼리가 em.persist() 시점에 나가는 게 아니라 트랜잭션이 커밋되는 시점에 나간다.
  ![img_3.png](img_3.png)
- 준영속 상태
  - 이미 영속성 컨텍스트에 등록된(=영속 상태) 엔티티를 컨텍스트에서 분리했을 때의 상태를 말한다. 분리하게 될 경우, 해당 엔티티는 더이상 영속성 컨텍스트에서 관리되지 않는다.
  - 구현 방식은 `em.detach()` 메소드를 호출함으로써 이뤄진다.
- 삭제
  - 엔티티를 삭제한 상태를 말한다. 이 경우 DB에서도 해당 엔티티가 삭제된다. `em.remove()` 메소드를 호출하면 해당 엔티티가 삭제된다.

## 영속성 컨텍스트의 이점